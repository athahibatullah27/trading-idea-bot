# Name of your workflow (optional, but good practice)
name: Docker CI/CD

# Events that trigger this workflow
on:
  # push:
  #   branches:
  #     - master # Trigger on pushes to the 'main' branch
  # pull_request:
  #   branches:
  #     - master # Trigger on pull requests targeting 'main'
  push:
    branches:
      - supabase-integration # Trigger on pushes to the 'supabase-integration' branch

# Define one or more jobs
jobs:
  build-and-push: # Name of this job
    runs-on: ubuntu-latest # The type of runner to use (e.g., Ubuntu Linux)

    steps: # A sequence of tasks to be performed in this job
      - name: Checkout code # Step 1: Get your code from the repository
        uses: actions/checkout@v4 # Uses a pre-built action to checkout the repository

      - name: Log in to Docker Hub # Step 2: Authenticate with Docker Hub (or your chosen registry)
        uses: docker/login-action@v3 # Uses a pre-built action for Docker login
        with:
          username: ${{ secrets.DOCKER_USERNAME }} # Accesses a GitHub Secret for username
          password: ${{ secrets.DOCKER_PASSWORD }} # Accesses a GitHub Secret for password

      - name: Build Docker image # Step 3: Build your Docker image
        run: docker build . --file Dockerfile --tag iscav/trade-bot-backend:${{ github.sha }} # Runs a shell command to build the image
        # Replace 'your-docker-repo/your-image-name' with your actual Docker repository and image name.
        # ${{ github.sha }} is a built-in variable that provides the commit SHA, useful for unique tags.

      - name: Push Docker image # Step 4: Push the built image to the registry
        run: docker push iscav/trade-bot-backend:${{ github.sha }} # Runs a shell command to push the image

      # You would add more steps here for testing, e.g.,
      # - name: Run tests
      #   run: docker run your-docker-repo/your-image-name:${{ github.sha }} npm test
  deploy: # This is a new job for deployment
    runs-on: ubuntu-latest
    needs: build-and-push # This job depends on the 'build-test-and-push' job succeeding
    environment: production # Optional: Link to a GitHub Environment for deployment protection rules

    steps:
      - name: Deploy to Production Server
        uses: appleboy/ssh-action@master # A popular action for executing commands over SSH
        with:
          host: ${{ secrets.SSH_HOST }} # IP address or hostname of your server
          username: ${{ secrets.SSH_USERNAME }} # SSH username for your server
          key: ${{ secrets.SSH_PRIVATE_KEY }} # Your SSH private key (stored as a GitHub Secret)
          script: | # Commands to execute on the remote server
            echo "Connecting to production server..."
            # Navigate to your application's directory on the server
            cd trading-idea-bot/ 

            # Pull the latest Docker image from your registry
            # Replace 'your-docker-repo/your-image-name' with your actual image name
            # and 'your-service-name' with the service name from your docker-compose.yml
            echo "Pulling latest Docker image..."
            docker compose pull backend # Assuming 'backend' is the service name in your docker-compose.yml

            # Stop and remove the old container, then start a new one with the updated image
            # The '--no-deps' flag ensures only the specified service is updated, not its dependencies
            echo "Updating and restarting backend service..."
            docker compose up -d --no-deps backend

            echo "Deployment complete!"
